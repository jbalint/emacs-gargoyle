#+TITLE: Type Mappings in Gargoyle

This document describes the facility mapping types in two cases:
+ E2J (Emacs to Java) - arguments from Lisp calls to Java methods
+ J2E (Java to Emacs) - values returned from calls to Java methods to
  Lisp code

* E2J Type Mapping

** E2J Mapping Concepts

  When calling Java methods from Lisp, the arguments can be Lisp
  values or [Lisp representations of] Java objects. The type mapping
  determines which versions of an overloaded methods are valid for the
  given call and how Lisp values are transformed to Java objects.

  We consider the following elements of a method call:
  + A (E2J) /type mapping/ is an entry in the =gg-to-java-mappings=
    list
  + A /target object/ upon which a method is being call
  + The /target type/ is the Java class of the target object
  + The /argument list/ is the list of arguments to the Lisp call
  + A set of /candidate methods/ which are associated with the target
    type corresponding to the method name begin called and arity equal
    to the length of the argument list
  + A /candidate list of types/ corresponding to the argument types
    declared for each candidate method
  + The /target method/ is the Java method ID of the candidate method
    that is chosen to be called

  The variable *=gg-to-java-mappings=* is a list detailing possible
  mappings to a Java types. Each element is a 3-element list:
  1. A symbol representing the Java class of objects to be created by
     the mapping
  2. A predicate which tests whether a value can be mapped to the type
     specified by this mapping
  3. A function (symbol or subr) which does the mapping from Lisp
     value to Java object

** E2J Use Cases and Examples

*** Lisp string as Java =String=

   The built-in mapping handles Lisp strings using this facility.

#+BEGIN_SRC elisp
  (add-to-list 'gg-to-java-mapping-alist
               '(java.util.String stringp gg-new-string))
#+END_SRC

*** Lisp list as Java =List=

   If we wish to map Lisp lists to Java =List=s can add a mapping:

#+BEGIN_SRC elisp
  (defun my-list-to-java-LinkedList (l)
    (let ((newlist (gg-new "java.util.LinkedList")))
      (-map (lambda (it) (/add newlist it)) l)
      newlist))

  (add-to-list 'gg-to-java-mappings
               '(java.util.LinkedList ;; type the mapping creates
                 listp ;; predicate whether the value can map to this type
                 my-list-to-java-LinkedList))
#+END_SRC

   N.B. This mapping declares the 

*** Lisp string of comma-separated string values as Java =List=

#+BEGIN_SRC elisp
  (add-to-list 'gg-to-java-mappings
               '(java.util.LinkedList
                 stringp
                 (lambda (s)
                   (let ((l (split-string s ",")))
                     ;; this function is defined in the previous example
                     (my-list-to-java-LinkedList l)))))
#+END_SRC

** Target Method Selection Algorithm

*** Building the Set of Candidate Methods

	Given the in-memory structure of the class hierarchy, TODO ...

** Implementation

   + The lowest level of calling a method is =gg--call-method-raw=
     which takes the following arguments:
	 + =target= The raw object on which the method will be called.
	 + =methodID= The raw method ID indicating which method to call.
	 + =args= Ordered list of pairs. First element is a symbol
       indicating the type of the value. The second element is the
       value. Possible types are as follow (defined by =jvalue= in
       =jni.h=):
	   + =z= A boolean value given as one of the following:
		 + an integer in which case 0 is false and any other value is
           true (JNI interpretation)
		 + a symbol =t= to indicate true
		 + =nil= to indicate false
	   + =b= A byte value given as an integer.
	   + =c= A char value given as an integer.
	   + =s= A short value given as an integer.
	   + =i= An int value given as an integer.
	   + =j= A long value given as an integer.
	   + =f= A float value given as a float.
	   + =d= A double value given as a float.
	   + =l= A raw Java object given as a userptr.

   + The type mapping takes place via (>>>?)

* J2E Type Mapping

* Further Work

  + Emacs defines the limits of integers (c.f. =most-positive-fixnum=)
    more narrowly than Java. Some constants may be defined outside
    this range and should be able to be represented as strings in Lisp
    and mapped to long values in C/Java.

#+BEGIN_SRC elisp
  (defun transformit (it)
    "a STRING isntead")

  (setq my-alist
        '((listp . transformit)))

  (defun transform-value-accordingly (it)
    "Transform a value according to the first applicable mapping in gg-lisp-to-java-alist"
    (let* ((pred (lambda (mapping) (funcall (car mapping) it)))
           (transformer (cdr (-first pred my-alist))))
      (funcall transformer it)))
#+END_SRC
